<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>BBG Awards 결과 / 집계</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
    }
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      font-size: 24px;
      text-align: center;
      margin: 16px 0 12px;
    }
    p.desc {
      font-size: 13px;
      color: #9ca3af;
      margin: 0 0 16px;
      text-align: center;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #1e293b;
    }
    button.primary {
      background: #22c55e;
      color: #022c22;
    }
    .card {
      background: #0f172a;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.4);
    }
    .card h2 {
      font-size: 18px;
      margin: 0 0 6px;
    }
    .card small {
      display: block;
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 8px;
    }
    .section-body {
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>BBG Awards 결과 / 집계</h1>
    <p class="desc">
      이 페이지는 관리자용입니다. Supabase DB에서 투표 데이터를 읽어와<br />
      사람 선택형(<code>kind = 'person'</code>) / 주관식(<code>'text'</code>) / 옵션형(<code>'option'</code>) 상들을 요약해서 보여줍니다.<br />
      사람 선택형 상은 1인 1상 규칙에 따라 예상 수상자를 계산할 수 있습니다.
    </p>

    <div class="btn-row">
      <button id="reload-btn" class="secondary">데이터 다시 불러오기</button>
      <button id="unique-btn" class="primary">1인 1상 규칙으로 수상자 계산</button>
    </div>

    <div class="card">
      <h2>1. 사람 선택형 상 결과 (kind = 'person')</h2>
      <small>마감 시간이 지난 상들에 대해 1인 1상 기준으로 예상 수상자를 계산합니다.</small>
      <div id="person-results" class="section-body">로딩 중...</div>
    </div>

    <div class="card">
      <h2>2. 주관식 상 요약 (kind = 'text')</h2>
      <small>같은 답변은 합쳐서 표시합니다. (대소문자/띄어쓰기 단순 정리)</small>
      <div id="text-results" class="section-body">로딩 중...</div>
    </div>

    <div class="card">
      <h2>3. 옵션형 상 요약 (kind = 'option')</h2>
      <small>각 옵션에 대한 득표수를 집계합니다.</small>
      <div id="option-results" class="section-body">로딩 중...</div>
    </div>
  </div>

  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // index.html 과 동일한 설정
    const SUPABASE_URL = "https://stjdvynonapqwkhdsdbf.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_BJOCLYogz4rTiqadKrXpHw_FHtVX--d";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const personResultsEl = document.getElementById('person-results');
    const textResultsEl = document.getElementById('text-results');
    const optionResultsEl = document.getElementById('option-results');
    const reloadBtn = document.getElementById('reload-btn');
    const uniqueBtn = document.getElementById('unique-btn');

    let latestData = null;

    function safeText(t) {
      return (t || '').trim();
    }

    function formatDateTime(value) {
      if (!value) return '';
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) return '';
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      const hh = String(d.getHours()).padStart(2, '0');
      const mi = String(d.getMinutes()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    async function loadData() {
      personResultsEl.textContent = '로딩 중...';
      textResultsEl.textContent = '로딩 중...';
      optionResultsEl.textContent = '로딩 중...';

      const [
        { data: awards, error: aErr },
        { data: users, error: uErr },
        { data: options, error: oErr },
        { data: votes, error: vErr },
      ] = await Promise.all([
        supabaseClient.from('awards')
          .select('id,title,kind,end_at,description,sort_order,created_at')
          .order('sort_order', { ascending: true })
          .order('created_at', { ascending: true }),
        supabaseClient.from('users')
          .select('id,name')
          .order('name', { ascending: true }),
        supabaseClient.from('award_options')
          .select('award_id,key,label'),
        supabaseClient.from('votes')
          .select('award_id,voter_id,candidate_id,answer_text,choice_key'),
      ]);

      if (aErr || uErr || vErr) {
        console.error(aErr || uErr || vErr);
        personResultsEl.textContent = '데이터 불러오기 오류';
        textResultsEl.textContent = '데이터 불러오기 오류';
        optionResultsEl.textContent = '데이터 불러오기 오류';
        return;
      }

      latestData = {
        awards: awards || [],
        users: users || [],
        options: options || [],
        votes: votes || []
      };
      renderAll(latestData, false);
    }

    function buildUsersMap(users) {
      const map = {};
      users.forEach(u => { map[u.id] = u; });
      return map;
    }

    function buildOptionsMap(options) {
      const map = {};
      options.forEach(o => {
        if (!map[o.award_id]) map[o.award_id] = {};
        map[o.award_id][o.key] = o;
      });
      return map;
    }

    // 1인 1상 규칙용 계산
    function computeUniqueWinners(awards, votes) {
      const now = new Date();
      const personAwards = awards.filter(a =>
        a.kind === 'person' && a.end_at && new Date(a.end_at) <= now
      );

      // sort_order → created_at 순으로 정렬
      personAwards.sort((a,b) => {
        const sa = a.sort_order ?? 0;
        const sb = b.sort_order ?? 0;
        if (sa !== sb) return sa - sb;
        return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
      });

      const votesByAward = {};
      votes.forEach(v => {
        if (!v.candidate_id) return;
        if (!votesByAward[v.award_id]) votesByAward[v.award_id] = {};
        const m = votesByAward[v.award_id];
        m[v.candidate_id] = (m[v.candidate_id] || 0) + 1;
      });

      const winners = {};          // award_id -> {candidate_id, count}
      const alreadyWon = new Set(); // 이미 다른 상 받은 사람

      personAwards.forEach(a => {
        const counts = votesByAward[a.id] || {};
        const rows = Object.entries(counts).map(([cid, cnt]) => ({
          candidate_id: cid,
          count: cnt,
        }));
        rows.sort((x,y) => y.count - x.count); // 득표수 높은 순

        for (const row of rows) {
          if (!alreadyWon.has(row.candidate_id)) {
            winners[a.id] = row;
            alreadyWon.add(row.candidate_id);
            break;
          }
        }
      });

      return winners;
    }

    function renderAll(data, applyUniqueRule) {
      const { awards, users, options, votes } = data;
      const usersById = buildUsersMap(users);
      const optionsByAward = buildOptionsMap(options);
      const now = new Date();

      const uniqueWinners = applyUniqueRule ? computeUniqueWinners(awards, votes) : {};

      // --- 1. 사람 선택형 ---
      const personAwards = awards.filter(a => a.kind === 'person');
      if (personAwards.length === 0) {
        personResultsEl.textContent = '사람 선택형 상이 없습니다.';
      } else {
        const frag = document.createDocumentFragment();
        personAwards.forEach(a => {
          const wrap = document.createElement('div');
          wrap.style.marginBottom = '16px';

          const title = document.createElement('div');
          title.style.fontWeight = '600';
          title.textContent = a.title;
          wrap.appendChild(title);

          const sub = document.createElement('div');
          sub.style.fontSize = '12px';
          sub.style.color = '#9ca3af';
          const closed = a.end_at && new Date(a.end_at) <= now;
          sub.textContent = closed
            ? `마감됨 · 마감 시각: ${formatDateTime(a.end_at)}`
            : `진행 중 · 마감 시각: ${formatDateTime(a.end_at) || '미설정'}`;
          wrap.appendChild(sub);

          const table = document.createElement('table');
          table.style.width = '100%';
          table.style.fontSize = '13px';
          table.style.borderCollapse = 'collapse';
          table.style.marginTop = '4px';

          const thead = document.createElement('thead');
          const trh = document.createElement('tr');
          ['순위','이름','득표수'].forEach(txt => {
            const th = document.createElement('th');
            th.textContent = txt;
            th.style.borderBottom = '1px solid #1f2937';
            th.style.textAlign = txt === '이름' ? 'left' : 'right';
            th.style.padding = '2px 4px';
            trh.appendChild(th);
          });
          thead.appendChild(trh);
          table.appendChild(thead);

          const tbody = document.createElement('tbody');

          const counts = {};
          votes
            .filter(v => v.award_id === a.id && v.candidate_id)
            .forEach(v => {
              counts[v.candidate_id] = (counts[v.candidate_id] || 0) + 1;
            });

          const rows = Object.entries(counts).map(([cid, cnt]) => ({
            candidate_id: cid,
            name: (usersById[cid] && usersById[cid].name) || '(알 수 없음)',
            count: cnt,
          }));
          rows.sort((x,y) => y.count - x.count);

          rows.forEach((row, idx) => {
            const tr = document.createElement('tr');
            const isWinner =
              uniqueWinners[a.id] &&
              String(uniqueWinners[a.id].candidate_id) === String(row.candidate_id);

            ['rank','name','count'].forEach(col => {
              const td = document.createElement('td');
              td.style.padding = '2px 4px';
              td.style.borderBottom = '1px solid #0f172a';
              td.style.textAlign = col === 'name' ? 'left' : 'right';
              if (col === 'rank') td.textContent = idx + 1;
              if (col === 'name') td.textContent = row.name;
              if (col === 'count') td.textContent = row.count;
              if (isWinner) td.style.color = '#4ade80';
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });

          if (rows.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 3;
            td.textContent = '아직 투표가 없습니다.';
            td.style.padding = '4px';
            td.style.fontSize = '12px';
            td.style.color = '#9ca3af';
            tr.appendChild(td);
            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          wrap.appendChild(table);

          if (uniqueWinners[a.id]) {
            const info = document.createElement('div');
            info.style.fontSize = '12px';
            info.style.color = '#bbf7d0';
            const w = uniqueWinners[a.id];
            const u = usersById[w.candidate_id];
            info.textContent = `1인 1상 규칙 적용 예상 수상자: ${u ? u.name : '(알 수 없음)'} (${w.count}표)`;
            wrap.appendChild(info);
          }

          frag.appendChild(wrap);
        });
        personResultsEl.innerHTML = '';
        personResultsEl.appendChild(frag);
      }

      // --- 2. 주관식 ---
      const textAwards = awards.filter(a => a.kind === 'text');
      if (textAwards.length === 0) {
        textResultsEl.textContent = '주관식 상이 없습니다.';
      } else {
        const frag = document.createDocumentFragment();
        textAwards.forEach(a => {
          const wrap = document.createElement('div');
          wrap.style.marginBottom = '16px';

          const title = document.createElement('div');
          title.style.fontWeight = '600';
          title.textContent = a.title;
          wrap.appendChild(title);

          const list = document.createElement('ul');
          list.style.fontSize = '13px';
          list.style.margin = '4px 0 0 16px';

          const counts = {};
          votes
            .filter(v => v.award_id === a.id && safeText(v.answer_text))
            .forEach(v => {
              const key = safeText(v.answer_text);
              counts[key] = (counts[key] || 0) + 1;
            });

          const rows = Object.entries(counts).map(([text, cnt]) => ({ text, count: cnt }));
          rows.sort((x,y) => y.count - x.count);

          if (rows.length === 0) {
            const li = document.createElement('li');
            li.textContent = '아직 응답이 없습니다.';
            li.style.color = '#9ca3af';
            list.appendChild(li);
          } else {
            rows.forEach(row => {
              const li = document.createElement('li');
              li.textContent = `${row.text} — ${row.count}표`;
              list.appendChild(li);
            });
          }

          wrap.appendChild(list);
          frag.appendChild(wrap);
        });
        textResultsEl.innerHTML = '';
        textResultsEl.appendChild(frag);
      }

      // --- 3. 옵션형 ---
      const optionAwards = awards.filter(a => a.kind === 'option');
      if (optionAwards.length === 0) {
        optionResultsEl.textContent = '옵션형 상이 없습니다.';
      } else {
        const frag = document.createDocumentFragment();
        optionAwards.forEach(a => {
          const wrap = document.createElement('div');
          wrap.style.marginBottom = '16px';

          const title = document.createElement('div');
          title.style.fontWeight = '600';
          title.textContent = a.title;
          wrap.appendChild(title);

          const list = document.createElement('ul');
          list.style.fontSize = '13px';
          list.style.margin = '4px 0 0 16px';

          const counts = {};
          votes
            .filter(v => v.award_id === a.id && v.choice_key)
            .forEach(v => {
              counts[v.choice_key] = (counts[v.choice_key] || 0) + 1;
            });

          const rows = Object.entries(counts).map(([key, cnt]) => {
            const opt = optionsByAward[a.id] && optionsByAward[a.id][key];
            const label = opt ? opt.label : key;
            return { key, label, count: cnt };
          });
          rows.sort((x,y) => y.count - x.count);

          if (rows.length === 0) {
            const li = document.createElement('li');
            li.textContent = '아직 투표가 없습니다.';
            li.style.color = '#9ca3af';
            list.appendChild(li);
          } else {
            rows.forEach(row => {
              const li = document.createElement('li');
              li.textContent = `${row.label} — ${row.count}표`;
              list.appendChild(li);
            });
          }

          wrap.appendChild(list);
          frag.appendChild(wrap);
        });
        optionResultsEl.innerHTML = '';
        optionResultsEl.appendChild(frag);
      }
    }

    reloadBtn.addEventListener('click', () => loadData());
    uniqueBtn.addEventListener('click', () => {
      if (!latestData) return;
      renderAll(latestData, true);
    });

    loadData();
  </script>
</body>
</html>
